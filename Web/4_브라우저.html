<html>
  <head>
    <title>웹 브라우저</title>
    <style>
      section {
        margin-bottom: 60px;
      }
    </style>
  </head>

  <body>
    <h1>웹 브라우저</h1>

    <section>
      <h3>웹 브라우저</h3>
      <p>인터넷을 통해 HTML로 작성된 웹페이지를 탐색하고 보는데 사용되는 프로그램</p>
      <p>웹 브라우저 별로 특징이 있고, 그로인해 장단점이 있다.</p>
      <p>점유율이 가장 높은건 구글이 개발한 크롬, 그 뒤는 애플이 개발하고 IOS에서만 사용할 수 있는 사파리</p>
    </section>

    <section>
      <h3>주요 기능</h3>
      <p>해당 기능들은 JS 공부할때 할것</p>
      <p>
        저장소<br />
        이벤트<br />
        BOM, DOM, Node<br />
        Browser API
      </p>
    </section>

    <section>
      <h3>기본적 구성요소</h3>
      <div>
        <h4>사용자 인터페이스 (UI)</h4>
        <p>상단 - 뒤로가기, 새로고침, 주소창 등등</p>
      </div>
      <div>
        <h4>브라우저 엔진</h4>
        <p>사용자 인터페이스와 렌더링 엔진의 사이의 동작 제어 엔진</p>
        <p>Ex: 새로고침 버튼을 누르면 </p>
      </div>
      <div>
        <h4>렌더링 엔진</h4>
        <p>내가 보고있는 웹 페이지별 화면은 렌더링 엔진이 그린 웹 페이지를 보고있는 것</p>
        <p>크롬의 경우 Webkit에서 파생된 Blink 엔진</p>
      </div>
      <div>
        <h4>통신</h4>
        <p>HTTP 요청과 같은 네트워크 호출에 사용</p>
      </div>
      <div>
        <h4>자바스크립트 해석기</h4>
        <p>자바스크립트 인터프리터 - 자바스크립트를 해석하고 실행한다</p>
        <p>크롬의 경우 V8 엔진</p>
      </div>
      <div>
        <h4>UI 백엔드</h4>
        <p>브라우저가 동작하고 있는 OS의 인터페이스를 따르는 UI를 처리</p>
        <p>예시: select, alert</p>
      </div>
      <div>
        <h4>자료 저장소</h4>
        <p>로컬스토리지, 세션스토리지, 쿠키</p>
      </div>
    </section>

    <section>
      <h3>브라우저는 어떻게 동작하는가?</h3>
      <p>통신을 통해 받아온 내용을 화면에 표시하는 렌더링 엔진을 주의깊게 봐야한다.</p>
      <p>깊게 들어가면 초기 통신부터 DNS, TCP 등 내용이 있지만 네트워크에 대한 깊은 이해는 기본 공부 이후에 시작</p>

      <div>
        <p>사용자가 사용자 인터페이스인 브라우저 주소창에 원하는 문서의 주소를 입력 (예: google.com)</p>
        <p>인터넷 상에서 서버를 찾기 위해선 IP주소를 알아야 한다.</p>
        <p>하지만 IP주소를 외우긴 어렵기 때문에 인간이 보기 쉽게 문자로 표현한 주소가 도메인 네임</p>
        <p>DNS는 도메인 네임을 IP 주소로 변환해주는 시스템 (Domain Name System)</p>

        <p>다시, 유저가 도메인을 포함한 문서의 주소를 주소창에 입력</p>
        <p>브라우저 엔진이 서버에 요청 전에 자료 저장소를 우선 탐색한다.</p>
        <p>자료 저장소에 자주 사용되는 데이터나 값을 복사해 놓은 임시 장소인 캐시를 탐색한다.</p>
        <p>캐시에 필요한 값이 있으면 불필요한 통신 낭비를 줄일 수 있다</p>

        <p>없으면 DNS에 도메인에 해당하는 IP주소를 얻어온다.</p>
        <p>IP주소를 가지고 해당 서버에 html파일을 요청한다.</p>
        <p>서버는 HTML파일을 8비트의 데이터 형태로 전송한다(바이트 스트림)</p>

        <p>브라우저는 전송받은 데이터를 문자로 변환하고, 하나씩 읽어가며 해당 문자가 HTML 코드인지 확인한다.</p>
        <p>해당 과정을 토큰화라고 함</p>

        <p>토큰을 객체로 만들고 이를 Node라고 함</p>
        <p>노드들에게 관계를 부여해 하나의 거대한 트리구조를 이룬다</p>
        <p>이를 DOM Tree 라고 함</p>

        <p>간단하게 표현하자면 브라우저가 HTML 코드를 해석해서 요소들을 트리 구조로 표현한 DOM Tree를 생성한다.</p>
      </div>

      <div>
        <p>HTML을 읽어나가다가 link나 img를 만나면 해당 자원을 요청한다.</p>
        <p>응답받은 파일이 CSS면 HTML 파싱 과정과 굉장히 유사하게 CSSOM 트리를 만든다.</p>
        <p>DOM과 SCCOM이 둘다 완성되어야 그리기 시작해서 CSSOM 파일이 크면 느리다. 즉 성능에 중요한 역할을 한다.</p>
      </div>

      <div>
        <p>또 읽어나가다가 script를 만나서 Js가 실행되면 DOM 파싱을 멈추게 된다.</p>
        <p>JS안에서 아직 읽히지 않은 HTML 태그를 변경하려고 하는 경우 에러가 난다. DOM 파싱이 멈췄으니까</p>
        <p>그래서 보편적으로 DOM파싱과 같이 진행되는 CSS는 상단에, DOM 파싱을 멈추는 스크립트는 하단에 코딩한다.</p>
        <p>물론 이건 상황에 따라 다르고, 스크립트 태그에 async, defer 를 활용할 수 있다 - 추후 JS할때 확인</p>
      </div>

      <div>
        <p>만들어진 DOM트리와 CSSOM트리를 합쳐서 렌더 트리를 생성한다.</p>
        <p>화면에 그리기 위한 최종 설계도</p>
        <p>화면을 그릴때 불필요한 요소들은 다 제거한다 - head태그, display: none 등</p>
      </div>

      <div>
        <p>레이아웃 단계 (리플로우)</p>
        <p>뷰포트의 크기에 맞게 좌표, 크기 계산</p>
        <p>리플로우를 발생시키는 것들이 있다(노드 추가, 변경, 삭제, 크기 변경, 좌표 변경 등)</p>
      </div>

      <div>
        <p>페인트 단계 (리페인트)</p>
        <p>화면을 여러개의 레이어로 나눠서 그림 (포토샵 생각)</p>
        <p>그후 합침 - composite</p>
      </div>
    </section>

    <section>
      <h3>성능을 좋게 하려면</h3>
      <p>소스의 사이즈 줄이기</p>
      <p>외부에서 가져오는 리소스 크기 줄이기</p>
      <p>외부에서 가져오는 리소스 양 줄이기</p>
      <p>리플로우, 리페인트 줄이기</p>
      <p>transform, opacity는 리플로우, 리페인트를 발생 시키지 않음(GPU 사용)</p>
    </section>
  </body>
</html>